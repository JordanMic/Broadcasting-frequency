<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <title>AG - Transmiters</title>

    <link rel="stylesheet" href="style.css">
    <script src="lib/Global.js" language="javascript"></script>
    <script src="lib/XMLWriter.js" language="javascript"></script>


</head>

<body>

    <main>
        <h1>13. Problem przydziału częstotliwości w sieci komórkowej</h1>
        <a href="#" onclick="Write();">Generuj strukture xml</a>

        <br /><br />
        <p id="fi-res">Wyjście:</p>
        <form><textarea id="ExampleOutput" style="width:100%" rows="10"></textarea></form>
        <input type="file" accept=".gxl" onchange="openFile(event)">
        <p id="sc-res">Wyjście:</p>
        <p class="console"><span id="result"></span></p>
    </main>

    <script language="javascript" type="text/javascript">
        //funkcja losująca
        function rand(min, max) {
            min = parseInt(min, 10);
            max = parseInt(max, 10);

            if (min > max) {
                let tmp = min;
                min = max;
                max = tmp;
            }

            return Math.floor(Math.random() * (max - min + 1) + min);
        }

        //tablica przechowująca dane o nadajnikach
        var transmitersNumber = 4;
        var transmiters = new Array();

        //konstruktor obiektu nadajnika
        function Transmiter(x, y, r) {
            this.x = x;
            this.y = y;
            this.r = r;
        }

        function TransmiterEdge(f, t) {
            this.f = f;
            this.t = t;
        }

        let transmitersEdges = new Array();


        //generowanie struktury xml
        function Write() {

            var XML = new XMLWriter();

            var x, y, r;

            for (var i = 0; i < transmitersNumber; i++) {

                x = rand(1, 20);
                y = rand(1, 20);
                r = rand(1, 20);


                XML.BeginNode("node");
                XML.Attrib("id", "" + i + "");

                XML.BeginNode("attr");
                XML.Attrib("name", "x");
                XML.Node("float", "" + x + "");
                XML.EndNode();


                XML.BeginNode("attr");
                XML.Attrib("name", "y");
                XML.Node("float", "" + y + "");
                XML.EndNode();


                XML.BeginNode("attr");
                XML.Attrib("name", "r");
                XML.Node("float", "" + r + "");
                XML.EndNode();

                XML.EndNode();


                document.getElementById("ExampleOutput").value = XML.ToString().replace(/</g, "\n<");



                // wrzucanie nadajników do tablicy
                transmiters[i] = new Transmiter(x, y, r);

            }
        }






        //wybór pliku i wcztanie:
        let openFile = function (event) {
            let input = event.target;
            let reader = new FileReader();

            reader.readAsText(input.files[0]);

            reader.onload = function () {
                let text = reader.result;
                parser = new DOMParser();
                gxl = parser.parseFromString(text, "text/xml");



                //dodanie Wierzchołków do tablicy gxlNode
                // const gxlNode = new Array();
                // for (let i = 0; i <= gxl.getElementByTagName("node").length; i++) {
                //     gxlNode.push([gxl.getElementByTagName("node")[i].id]);
                // }



                let k = 0;

                for (i = 0; i < transmitersNumber; i++) {
                    x1 = transmiters[i].x;
                    y1 = transmiters[i].y;
                    r1 = transmiters[i].r;

                    for (let j = 0; j < transmitersNumber; j++) {
                        x2 = transmiters[j].x;
                        y2 = transmiters[j].y;
                        r2 = transmiters[j].r;

                        if (j != i) {
                            let dist = Math.hypot(x1 - x2, y1 - y2) - r1 - r2;


                            if (dist < 0) {
                                transmitersEdges[k] = new TransmiterEdge(i, j);
                                k = k + 1;

                            }

                        }
                    }
                }

                //tworzenie klasy Graph
                class Graph {
                    //definiowanie listy wierzchołków
                    constructor(noOfVertices) {
                        this.noOfVertices = noOfVertices;
                        this.AdjList = new Map();
                    }


                    addVertex(v) {
                        // inicjalizacja sąsiadującej listy z
                        // null array 
                        this.AdjList.set(v, []);
                    }

                    addEdge(v, w) {
                        // pobierz liste z wierzchołkami v i wsadź
                        // vertex w denoting edge between v and w 
                        this.AdjList.get(v).push(w);

                        // Gdy graf nie skierowany
                        // dodaj krawędź w obie strony
                        // this.AdjList.get(w).push(v);
                    }


                    // Prints the vertex and adjacency list 
                    printGraph() {

                        var print;
                        // get all the vertices 
                        var get_keys = this.AdjList.keys();

                        // iterate over the vertices 
                        for (var i of get_keys) {
                            // great the corresponding adjacency list 
                            // for the vertex 
                            var get_values = this.AdjList.get(i);
                            var conc = "";

                            // iterate over the adjacency list 
                            // concatenate the values into a string 
                            for (var j of get_values)
                                conc += j + " ";

                            // print the vertex and its adjacency list 
                            console.log(i + " -> " + conc);
                            print += i + " -> " + conc + "<br />";
                        }

                        return print;
                    }
                }


                // użycie klasy graph
                var g = new Graph(transmitersNumber); //gxl.getElementByTagName("node").lenght
                var vertices = new Array();

                for (i = 0; i < transmitersNumber; i++) {
                    vertices[i] = i;
                }

                // dodanie wierzchołka
                for (i = 0; i < vertices.length; i++) {
                    g.addVertex(vertices[i]);
                }

                // dodanie krawędzi
                for (i = 0; i < transmitersEdges.length; i++) {
                    g.addEdge(transmitersEdges[i].f, transmitersEdges[i].t);
                }

                // wypisanie grafu w postaci sąsiadującej listy
                // A -> B D E 
                // B -> A C 
                // C -> B E F 
                // D -> A E 
                // E -> A D F C 
                // F -> E C 

                document.getElementById("result").innerHTML = g.printGraph();

            }
        }




        // function Transmiter(x, y, r) {
        //     this.x = x;
        //     this.y = y;
        //     this.r = r;
        // }
        //
        // //wybor liczby nadajników i stworzenie tablicy z nadajnikami
        // let transmitersNumber = 3;
        // let transmiters = new Array();
        //
        // // wrzucanie nadajników do tablicy
        // for (let i = 0; i < transmitersNumber; i++) {
        //     transmiters[i] = new Transmiter(rand(1, 20), rand(1, 20), rand(1, 10));
        // }
        //
        // for (i = 0; i < transmitersNumber; i++) {
        //     for (let j = 0; j < transmitersNumber; j++) {
        //
        //     }
        // }
        // console.log(transmiters);


        //console.log(transmiters);
    </script>


</body>

</html>