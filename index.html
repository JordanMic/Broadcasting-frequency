<!DOCTYPE html>
<html lang="pl">

<head>
    <meta charset="UTF-8">
    <title>AG - Transmiters</title>

    <link rel="stylesheet" href="style.css">
    <script src="lib/Global.js" language="javascript"></script>
    <script src="lib/XMLWriter.js" language="javascript"></script>


</head>

<body>

    <main>
        <h1>13. Problem przydziału częstotliwości w sieci komórkowej</h1>
        <a href="#" onclick="Write();">Generuj strukture gxl</a>

        <br /><br />
        <p id="fi-res">Wyjście:</p>
        <form><textarea id="ExampleOutput" style="width:100%" rows="10"></textarea></form>
        <input type="file" accept=".gxl" onchange="openFile(event)">
        <p id="sc-res">Wyjście:</p>
        <p class="console"><span id="result"></span>
            <spam id="colorresult"></spam>
        </p>
    </main>

    <script language="javascript" type="text/javascript">
        //funkcja losująca
        function rand(min, max) {
            min = parseInt(min, 10);
            max = parseInt(max, 10);

            if (min > max) {
                let tmp = min;
                min = max;
                max = tmp;
            }

            return Math.floor(Math.random() * (max - min + 1) + min);
        }

        //tablica przechowująca dane o nadajnikach
        let transmitersNumber = 6;
        let transmiters = new Array();

        //konstruktor obiektu nadajnika
        function Transmiter(x, y, r, c) {
            this.x = x;
            this.y = y;
            this.r = r;
            this.c = c;
        }



        //konstruktor obiektu krawędzi
        function TransmiterEdge(f, t) {
            this.f = f;
            this.t = t;
        }

        let transmitersEdges = new Array();


        //generowanie struktury xml
        function Write() {

            var XML = new XMLWriter();

            let x, y, r;

            for (let i = 0; i < transmitersNumber; i++) {

                x = rand(1.0, 20.0);
                y = rand(1.0, 20.0);
                r = rand(1.0, 5.0);
                c = null;


                XML.BeginNode("node");
                XML.Attrib("id", "" + i + "");

                XML.BeginNode("attr");
                XML.Attrib("name", "x");
                XML.Node("float", "" + x + "");
                XML.EndNode();


                XML.BeginNode("attr");
                XML.Attrib("name", "y");
                XML.Node("float", "" + y + "");
                XML.EndNode();


                XML.BeginNode("attr");
                XML.Attrib("name", "r");
                XML.Node("float", "" + r + "");
                XML.EndNode();

                XML.EndNode();


                document.getElementById("ExampleOutput").value = XML.ToString().replace(/</g, "\n<");



                // wrzucanie nadajników do tablicy
                transmiters[i] = new Transmiter(x, y, r, c);

            }
        }

        //wybór pliku i wcztanie:
        let openFile = function (event) {
            let input = event.target;
            let reader = new FileReader();

            reader.readAsText(input.files[0]);

            reader.onload = function () {
                let text = reader.result;
                parser = new DOMParser();
                gxl = parser.parseFromString(text, "text/xml");


                let k = 0;

                for (i = 0; i < transmitersNumber; i++) {
                    x1 = transmiters[i].x;
                    y1 = transmiters[i].y;
                    r1 = transmiters[i].r;

                    for (let j = 0; j < transmitersNumber; j++) {
                        x2 = transmiters[j].x;
                        y2 = transmiters[j].y;
                        r2 = transmiters[j].r;

                        if (j != i) {
                            let dist = Math.hypot(x1 - x2, y1 - y2) - r1 - r2;


                            if (dist < 0) {
                                transmitersEdges[k] = new TransmiterEdge(i, j);
                                k = k + 1;

                            }

                        }
                    }
                }

                //tworzenie klasy Graph
                class Graph {
                    //definiowanie listy wierzchołków
                    constructor(noOfVertices) {
                        this.noOfVertices = noOfVertices;
                        this.AdjList = new Map();
                    }


                    addVertex(v) {
                        // inicjalizacja sąsiadującej listy
                        this.AdjList.set(v, []);
                    }

                    addEdge(v, w) {
                        this.AdjList.get(v).push(w);

                    }


                    // Prints the vertex and adjacency list 
                    printGraph() {

                        let print;
                        let get_keys = this.AdjList.keys();

                        for (let i of get_keys) {
                            let get_values = this.AdjList.get(i);
                            let conc = "";

                            for (let j of get_values)
                                conc += j + " ";

                            console.log(i + " -> " + conc);

                            if (print == undefined) {
                                print = i + " -> " + conc + "<br />";
                            } else {
                                print += i + " -> " + conc + "<br />";
                            }
                        }

                        return print;
                    }



                    //kolorowanie wierzchołów
                    color() {

                        let print;
                        let colored = new Array();
                        let useColor = 0;


                        let get_keys = this.AdjList.keys();

                        for (let i of get_keys) {

                            let get_values = this.AdjList.get(i);


                            for (let j of get_values) {

                                // useColor = 0;
                                if (transmiters[j].c == null) {
                                    continue;
                                } else {
                                    useColor = transmiters[j].c + 1;
                                }

                                console.log(j);
                            }

                            transmiters[i].c = useColor;
                            useColor = 0;
                            if (print == undefined) {
                                print = "nadajnik: " + i + " kolor: " + transmiters[i].c +
                                    "<br />";
                            } else {
                                print += "nadajnik: " + i + " kolor: " + transmiters[i].c +
                                    "<br />";
                            }


                        }

                        return print;


                    }
                }


                // użycie klasy graph
                let g = new Graph(transmitersNumber); //gxl.getElementByTagName("node").lenght
                let vertices = new Array();

                for (i = 0; i < transmitersNumber; i++) {
                    vertices[i] = i;
                }

                // dodanie wierzchołka
                for (i = 0; i < vertices.length; i++) {
                    g.addVertex(vertices[i]);
                }

                // dodanie krawędzi
                for (i = 0; i < transmitersEdges.length; i++) {
                    g.addEdge(transmitersEdges[i].f, transmitersEdges[i].t);
                }


                document.getElementById("result").innerHTML = g.printGraph() + "<br />" +
                    "Kolorowanie grafów: " + "<br />";

                document.getElementById("colorresult").innerHTML = g.color();

            }
        }
    </script>


</body>

</html>
